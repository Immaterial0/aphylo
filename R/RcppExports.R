# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

normal_prop <- function(x, lb, ub, scale) {
    .Call('phylogenetic_normal_prop', PACKAGE = 'phylogenetic', x, lb, ub, scale)
}

gibbs_sampler <- function(fun, x, lb, ub, scale) {
    .Call('phylogenetic_gibbs_sampler', PACKAGE = 'phylogenetic', fun, x, lb, ub, scale)
}

MCMCcpp <- function(fun, theta0, nbatch, lb, ub, scale) {
    .Call('phylogenetic_MCMCcpp', PACKAGE = 'phylogenetic', fun, theta0, nbatch, lb, ub, scale)
}

#' Matrix of states
#' 
#' @param P Integer scalar. Number of functions.
#' @return A matrix of size 2^P by P with all the possible
#' (0,1) combinations of functions.
#' @examples
#' states(3)
#' @export
states <- function(P) {
    .Call('phylogenetic_states', PACKAGE = 'phylogenetic', P)
}

#' Probability Matrix
#' 
#' Generates a 2x2 matrix with probabilities for states 0/1, with rows and columns
#' corresponding to states (0,1) of parent and offspring respectively.
#' 
#' @param pr A numeric vector of length 2.
#' 
#' @return a 2x2 matrix with 0/1 probabilities, with rows and columns
#' corresponding to states (0,1) of parent and offspring respectively.
#' @export
prob_mat <- function(pr) {
    .Call('phylogenetic_prob_mat', PACKAGE = 'phylogenetic', pr)
}

#' Leaf probabilities
#' 
#' @param Z A matrix of size \eqn{N\times P}{N*P} with values \code{(0,1,9)}.
#' @param S A matrix of size \eqn{2^P*P} as returned by \code{\link{states}}.
#' @param psi A numeric vector of length 2.
#' @param noffspring A numeric vector of length \eqn{N}. Number of offspring
#' per node.
#' 
#' @export
leaf_prob <- function(Z, S, psi, noffspring) {
    .Call('phylogenetic_leaf_prob', PACKAGE = 'phylogenetic', Z, S, psi, noffspring)
}

#' Root node probabilities
#' 
#' @param pi A numeric vector of length 2 with root node probabilities.
#' @param S A numeric matrix of size 2^PxP with all possible states as
#' generated by \code{\link{states}}
#' 
#' Generates a vector of length 2^P with the root node probabilities
#' per state
#' @export
root_node_prob <- function(pi, S) {
    .Call('phylogenetic_root_node_prob', PACKAGE = 'phylogenetic', pi, S)
}

#' Internal node probabilities
#' 
#' @param Pr Probabilities (already with leaf probs).
#' @param mu Numeric vector of length 2 with gain/Loss probabilities.
#' @param S Integer matrix of size \eqn{2^p\times p}{2^p * p}. Possible 
#' functional states.
#' @param noffspring Integer vector of length \eqn{G} with number of offspring
#' per node.
#' @param offspring List of length \eqn{G} with vectors listing each nodes'
#' offspring.
#' @export
internal_prob <- function(Pr, mu, S, noffspring, offspring) {
    .Call('phylogenetic_internal_prob', PACKAGE = 'phylogenetic', Pr, mu, S, noffspring, offspring)
}

#' Computes Log-likelihood
#' 
#' This function computes the log-likelihood of the chosen parameters given
#' a particular dataset. The arguments \code{Z}, \code{offspring}, and
#' \code{noffspring} should be as those returned by \code{\link{get_offspring}}.
#' For complete Maximum Likelihood Estimation see \code{\link{mle}}.
#' 
#' @param Z A numeric matrix of size \eqn{N\times P}{N*P} with the function
#' states of each leaf (experimental data).
#' @param offspring A List of length \eqn{N} with the set of offspring of
#' each node.
#' @param noffspring An integer vector of length \eqn{N} with the number of
#' offspring per node.
#' @param psi A numeric vector of length 2 (see details).
#' @param mu A numeric vector of length 2 (see details).
#' @param Pi A numeric vector of length 2 (see details).
#' @param verb_ans Logical scalar. When \code{FALSE} (default) the function
#' returns a list with a single scalar (the log-likelihood).
#' 
#' @details
#' The parameters to estimate are described as follows:
#' \enumerate{
#' \item{\code{psi}: A vector of length 2 with \eqn{\psi_0}{psi[0]} and
#' \eqn{\psi_1}{psi[1]}, which are the misclassification probabilities fo
#' \eqn{s_p=0}{s[p]=0} and \eqn{s_p=1}{s[p]=1}
#' respectively.}
#' \item{\code{mu}: A vector of length 2 with \eqn{\mu_0}{mu[0]} and
#' \eqn{\mu_1}{mu[1]} which are the gain and loss probabilities respectively.}
#' \item{\code{Pi}: A vector of length 2 with \eqn{\pi_0}{pi[0]}} and
#' \eqn{\pi_1}{pi[1]}, which for now is specified as \eqn{(1 - \pi_1)}{(1 - pi[0]),
#' which holds the root node probabilities.}
#' }
#' @return A list of class \code{phylo_LogLik} with the following elements:
#' \item{S}{An integer matrix of size \eqn{2^p\times p}{2^p * p} as returned
#' by \code{\link{states}}.}
#' \item{PI}{A numeric vector of size \eqn{2^p} with each given state's root
#' node probabilities.}
#' \item{PSI}{A numeric matrix of size \eqn{G\times 2^p}{G * 2^p} with node/state
#' probabilities only including leaf node probabilities (this is for debugging).}
#' \item{Pr}{A numeric matrix of size \eqn{G\times 2^p}{G * 2^p} with node/state
#' probabilities.}
#' \item{ll}{A numeric scalar with the log-likelihood value given the chosen
#' parameters.}
#' @export
LogLike <- function(Z, offspring, noffspring, psi, mu, Pi, verb_ans = FALSE) {
    .Call('phylogenetic_LogLike', PACKAGE = 'phylogenetic', Z, offspring, noffspring, psi, mu, Pi, verb_ans)
}

#' Simulate functions on a ginven tree
#' 
#' @param offspring A List of length \eqn{N} with the set of offspring of
#' each node.
#' @param noffspring An integer vector of length \eqn{N} with the number of
#' offspring per node.
#' @param psi A numeric vector of length 2 (see details).
#' @param mu A numeric vector of length 2 (see details).
#' @param Pi A numeric vector of length 2 (see details).
#' @param P Integer scalar. Number of functions to simulate.
#' 
#' @details
#' 
#' Using the model described in the vignette
#' \link{../doc/peeling_phylo.html}
#' 
#' @return An matrix of size \code{length(offspring)*P} with values 9, 0 and 1
#' indicating \code{"no information"}, \code{"no function"} and \code{"function"}.
#' 
#' @export
#' @examples
#' # Example 1 ----------------------------------------------------------------
#' # Loading the data
#' data(experiment)
#' data(tree)
#'   
#' # Preprocessing the data
#' O <- get_offspring(experiment, "LeafId", tree, "NodeId", "ParentId")
#'     
#' # Simulating
#' ans <-
#'   with(O, sim_fun_on_tree(
#'       offspring,
#'       noffspring,
#'       psi = c(.001, .05) * 0,
#'       mu = c(.01, .05),
#'       Pi = c(.5, .5)
#'   ))
#'       
#' # Tabulating results
#' table(ans)
#' 
#' 
sim_fun_on_tree <- function(offspring, noffspring, psi, mu, Pi, P = 1L) {
    .Call('phylogenetic_sim_fun_on_tree', PACKAGE = 'phylogenetic', offspring, noffspring, psi, mu, Pi, P)
}

#' Random tree generation
#' 
#' By randomly choosing pairs of vertices, this function generates random
#' trees from bottom to top such that the labels of the nodes follow a 
#' partial order in their parent-offspring relation, with the parent
#' always having a lower idlabel than the offspring.
#' 
#' @param n Integer scalar. Number of leaf nodes.
#' 
#' @details The algorithm was implemented as follows
#' 
#' \enumerate{
#'   \item Initialize \code{left =[0,...,(n-1)]} and \code{m = 0}, and
#'         initialize the vectors \code{parent} and \code{offspring} to be
#'         empty.
#'   \item While \code{length(left) > 1} do:
#'   \enumerate{
#'     \item Randomly choose a pair \code{(i, j)} from \code{left}
#'     \item Add \code{leaf(i)}, \code{leaf(j)} to the tail of \code{offspring},
#'     \item Decrease \code{m} by 1, and add it two times to the tail of
#'     \code{parent}.
#'     \item Remove \code{(i,j)} from \code{leaf} and add \code{m} to its tail.
#'     \item next
#'   }
#'   
#'   \item Substract \code{m} to each element of both lists, this way the 
#'   root node will have id 0.
#' }
#' 
#' The \code{\link[ape:rtree]{rtree}} function in the \pkg{ape} package is similar,
#' although the big difference is in the way the labels are stablished. This later
#' point is crucial for both \pkg{phylogenetic} and \pkg{ape} as is a key feature
#' in some (most) of its routines.
#' 
#' @return An matrix of size \code{n*2 - 2} with column names \code{"offspring"} and
#' \code{"parent"} representing an edgelist with \code{n*2-1} nodes. A Directed
#' Acyclic Graph (DAG).
#' 
#' @examples
#' # A very simple example ----------------------------------------------------
#' set.seed(1223)
#' ans <- sim_tree(50);range(ans)
#' 
#' # To visualize it, we create a random experimental dataset
#' O <- get_offspring(
#'   data_exper  = data.frame(
#'     f = rep(1L, nrow(ans)),
#'     id = (nrow(ans)-1):nrow(ans)
#'     ),
#'   data_tree   = data.frame(ans),
#'   leafidvar   = "id", 
#'   nodeidvar   = "offspring",
#'   parentidvar = "parent"
#'   )
#' 
#' # Now we plot it as a phylo object
#' plot(as.phylo(O))
#' 
#' # This is what you would do in igraph --------------------------------------
#' \dontrun{
#' g   <- ans
#' g[] <- as.character(g)
#' g <- igraph::graph_from_edgelist(g)
#' plot(g, layout = igraph::layout_with_sugiyama(g)[[2]])
#' }
#' 
#' # A performance benchmark with ape::rtree ----------------------------------
#' \dontrun{
#' microbenchmark::microbenchmark(
#' ape = rtree(1e3),
#'   phy = sim_tree(1e3),
#' unit = "relative"
#' )
#' # This is what you would get.
#' # Unit: relative
#' #   expr      min       lq     mean  median       uq      max neval
#' #    ape 33.31827 31.85769 33.04708 30.8261 36.51258 25.75327   100
#' #    phy  1.00000  1.00000  1.00000  1.0000  1.00000  1.00000   100
#' }
#' @export
sim_tree <- function(n) {
    .Call('phylogenetic_sim_tree', PACKAGE = 'phylogenetic', n)
}

