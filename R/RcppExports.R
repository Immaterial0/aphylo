# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Approximation of Geodesic distances using Matrix Powers
#' 
#' Given an adjacency matrix \eqn{A}, the geodesic can be approximated using
#' its powers, since each \eqn{(i,j)} element of \eqn{A^p} corresponds to the
#' number of \eqn{p} length steps between nodes \eqn{i} and \eqn{j}.
#' 
#' @template parameters
#' @templateVar edges 1
#' @param nsteps Integer scalar. Number of maximum steps for the approximation.
#' @param warn Logical scalar. When \code{TRUE} shows a warning after no further
#' steps are needed.
#' @param undirected Logical scalar. When \code{TRUE} (default), the edgelist is treated
#' as undirected (see details).
#' @return A square matrix of size \eqn{n} with the shortest path between each
#' pair of nodes.
#' 
#' @details
#' When \code{undirected = TRUE}, the function extends \code{edges} such that
#' \code{edges = rbind(edges, edges[,2:1])}.
#' 
#' @author George G. Vega Yon
#' @references
#' This is a modified version of the function of the same name in the
#' R package \CRANpkg{netdiffuseR}.
#' @export
approx_geodesic <- function(edges, nsteps = 1e3L, undirected = TRUE, warn = FALSE) {
    .Call(`_aphylo_approx_geodesic`, edges, nsteps, undirected, warn)
}

#' Matrix of states
#' 
#' @param P Integer scalar. Number of functions.
#' @return A matrix of size 2^P by P with all the possible
#' (0,1) combinations of functions.
#' @examples
#' states(3)
#' @export
states <- function(P) {
    .Call(`_aphylo_states`, P)
}

prob_mat <- function(pr) {
    .Call(`_aphylo_prob_mat`, pr)
}

root_node_prob <- function(Pi, S) {
    .Call(`_aphylo_root_node_prob`, Pi, S)
}

#' State probabilities
#' 
#' Compute the state probabilities for each node in the tree using the peeling
#' algorithm. This function is the horse-power of the function \code{\link{LogLike}}
#' so it is not intended to be used directly.
#' 
#' @template parameters
#' @templateVar annotations 1
#' @templateVar mu 1
#' @templateVar psi 1
#' @templateVar S 1
#' @templateVar noffspring 1
#' @templateVar offspring 1
#' 
#' @export
#' @return A numeric matrix of size \eqn{n\times 2^P}{n * 2^P} with state
#' probabilities for each node.
#' 
probabilities <- function(annotations, mu, psi, S, noffspring, offspring) {
    .Call(`_aphylo_probabilities`, annotations, mu, psi, S, noffspring, offspring)
}

#' Computes Log-likelihood
#' 
#' This function computes the log-likelihood of the chosen parameters given
#' a particular dataset. The arguments \code{annotations}, \code{offspring}, and
#' \code{noffspring} should be as those returned by \code{\link{new_aphylo}}.
#' For complete Maximum Likelihood Estimation see \code{\link[=aphylo_estimates-class]{aphylo_estimates}}.
#' 
#' @template parameters
#' @templateVar annotations 1
#' @templateVar offspring 1
#' @templateVar noffspring 1
#' @templateVar psi 1
#' @templateVar mu 1
#' @templateVar Pi 1
#' @param verb_ans Logical scalar. When \code{FALSE} (default) the function
#' returns a list with a single scalar (the log-likelihood).
#' @param check_dims Logical scalar. When \code{TRUE} (default) the function
#' checks the dimmension of the passed parameters.
#' 
#' @details
#' The parameters to estimate are described as follows:
#' \enumerate{
#' \item{\code{psi}: A vector of length 2 with \eqn{\psi_0}{psi[0]} and
#' \eqn{\psi_1}{psi[1]}, which are the misclassification probabilities fo
#' \eqn{s_p=0}{s[p]=0} and \eqn{s_p=1}{s[p]=1}
#' respectively.}
#' \item{\code{mu}: A vector of length 2 with \eqn{\mu_0}{mu[0]} and
#' \eqn{\mu_1}{mu[1]} which are the gain and loss probabilities respectively.}
#' \item{\code{Pi}: A numeric scalar which for which equals the probability
#' of the root node having the function.}
#' }
#' @return A list of class \code{phylo_LogLik} with the following elements:
#' \item{S}{An integer matrix of size \eqn{2^p\times p}{2^p * p} as returned
#' by \code{\link{states}}.}
#' \item{Pr}{A numeric matrix of size \eqn{G\times 2^p}{G * 2^p} with node/state
#' probabilities.}
#' \item{ll}{A numeric scalar with the log-likelihood value given the chosen
#' parameters.}
#' @export
LogLike <- function(annotations, offspring, noffspring, psi, mu, Pi, verb_ans = FALSE, check_dims = TRUE) {
    .Call(`_aphylo_LogLike`, annotations, offspring, noffspring, psi, mu, Pi, verb_ans, check_dims)
}

predict_fun <- function(i, p, di0, annotations, offspring, noffspring, psi, mu, Pi) {
    .Call(`_aphylo_predict_fun`, i, p, di0, annotations, offspring, noffspring, psi, mu, Pi)
}

predict_funs <- function(ids, edges, annotations, offspring, noffspring, psi, mu, Pi) {
    .Call(`_aphylo_predict_funs`, ids, edges, annotations, offspring, noffspring, psi, mu, Pi)
}

prediction_score_rand <- function(A, W, alpha) {
    .Call(`_aphylo_prediction_score_rand`, A, W, alpha)
}

#' Simulate functions on a ginven tree
#' 
#' @param offspring A List of length \eqn{N} with the set of offspring of
#' each node.
#' @param noffspring An integer vector of length \eqn{N} with the number of
#' offspring per node.
#' @param psi A numeric vector of length 2 (see details).
#' @param mu A numeric vector of length 2 (see details).
#' @param Pi A numeric vector of length 2 (see details).
#' @param P Integer scalar. Number of functions to simulate.
#' 
#' @details
#' 
#' Using the model described in the vignette
#' \href{../doc/peeling_phylo.html}{peeling_phylo.html}
#' 
#' @return An matrix of size \code{length(offspring)*P} with values 9, 0 and 1
#' indicating \code{"no information"}, \code{"no function"} and \code{"function"}.
#' 
#' @export
#' @examples
#' # Example 1 ----------------------------------------------------------------
#' # We need to simulate a tree
#' set.seed(1231)
#' newtree <- sim_tree(1e3)
#' 
#' # Preprocessing the data
#'     
#' # Simulating
#' ans <- sim_fun_on_tree(
#'   newtree$offspring,
#'   newtree$noffspring,
#'   psi = c(.001, .05),
#'   mu = c(.01, .05),
#'   Pi = c(.5, .5)
#'   )
#'       
#' # Tabulating results
#' table(ans)
#' 
#' 
sim_fun_on_tree <- function(offspring, noffspring, psi, mu, Pi, P = 1L) {
    .Call(`_aphylo_sim_fun_on_tree`, offspring, noffspring, psi, mu, Pi, P)
}

#' Random tree generation
#' 
#' By randomly choosing pairs of vertices, this function generates random
#' trees from bottom to top such that the labels of the nodes follow a 
#' partial order in their parent-offspring relation, with the parent
#' always having a lower idlabel than the offspring.
#' 
#' @param n Integer scalar. Number of leaf nodes.
#' 
#' @details The algorithm was implemented as follows
#' 
#' \enumerate{
#'   \item Initialize \code{left =[n*2 - 2,...,(n-1)]} and \code{m = n*2 - 2}, and
#'         initialize the vectors \code{parent} and \code{offspring} to be
#'         empty.
#'   \item While \code{length(left) > 1} do:
#'   \enumerate{
#'     \item Randomly choose a pair \code{(i, j)} from \code{left}
#'     \item Add \code{leaf(i)}, \code{leaf(j)} to the tail of \code{offspring},
#'     \item Decrease \code{m} by 1, and add it two times to the tail of
#'     \code{parent}.
#'     \item Remove \code{(i,j)} from \code{leaf} and add \code{m} to its tail.
#'     \item next
#'   }
#'   
#' }
#' 
#' The \code{\link[ape:rtree]{rtree}} function in the \pkg{ape} package is similar,
#' although the big difference is in the way the labels are stablished. This later
#' point is crucial for both \pkg{phylogenetic} and \pkg{ape} as is a key feature
#' in some (most) of its routines.
#' 
#' @return A List with the following:
#' \item{edges}{An matrix of size \code{(n*2 - 2)*2}, an edgelist, with \code{n*2-1} nodes.
#' This, a Directed Acyclic Graph (DAG), as classes \code{matrix} and \code{po_tree}.}
#' \item{offspring}{A list of size \code{n*2 - 1} listing node ith's offspring if any.}
#' \item{noffspring}{An integer vector of size \code{n*2 - 1} indicating the number of
#' offspring that each node has.}
#' 
#' @examples
#' # A very simple example ----------------------------------------------------
#' set.seed(1223)
#' newtree <- sim_tree(50)$edges
#' 
#' plot(as.apephylo(newtree))
#' 
#' # This is what you would do in igraph --------------------------------------
#' \dontrun{
#' g   <- ans
#' g[] <- as.character(g)
#' g <- igraph::graph_from_edgelist(g)
#' plot(g, layout = igraph::layout_with_sugiyama(g)[[2]])
#' }
#' 
#' # A performance benchmark with ape::rtree ----------------------------------
#' \dontrun{
#' microbenchmark::microbenchmark(
#' ape = rtree(1e3),
#'   phy = sim_tree(1e3),
#' unit = "relative"
#' )
#' # This is what you would get.
#' Unit: relative
#'   expr     min       lq     mean  median       uq      max neval
#'    ape 14.7598 14.30809 14.30013 16.7217 14.32843 4.754106   100
#'    phy  1.0000  1.00000  1.00000  1.0000  1.00000 1.000000   100
#' }
#' @export
sim_tree <- function(n) {
    .Call(`_aphylo_sim_tree`, n)
}

fast_table <- function(x) {
    .Call(`_aphylo_fast_table`, x)
}

fast_table_using_labels <- function(x, ids) {
    .Call(`_aphylo_fast_table_using_labels`, x, ids)
}

recode_as_po <- function(edges) {
    .Call(`_aphylo_recode_as_po`, edges)
}

list_offspring <- function(edges) {
    .Call(`_aphylo_list_offspring`, edges)
}

