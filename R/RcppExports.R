# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Area Under the Curve and Receiving Operating Curve
#' 
#' The AUC values are computed by approximation using the area of the polygons formed
#' under the ROC curve.
#' @param pred A numeric vector with the predictions of the model. Values must
#' range between 0 and 1.
#' @param labels An integer vector with the labels (truth). Values should be either
#' 0 or 1.
#' @param nc Integer. Number of cutoffs to use for computing the rates and AUC.
#' @param nine_na Logical. When `TRUE`, 9 is treated as `NA`.
#' @return A list:
#' - `tpr` A vector of length `nc` with the True Positive Rates.
#' - `tnr` A vector of length `nc` with the True Negative Rates.
#' - `fpr` A vector of length `nc` with the False Positive Rates.
#' - `fnr` A vector of length `nc` with the False Negative Rates.
#' - `auc` A numeric value. Area Under the Curve.
#' - `cutoffs` A vector of length `nc` with the cutoffs used.
#' @export
auc <- function(pred, labels, nc = 200L, nine_na = TRUE) {
    .Call(`_aphylo_auc`, pred, labels, nc, nine_na)
}

#' Pointer to `pruner`
#' 
#' Creates an external pointer to an object of class `aphylo_pruner`. This is mostly
#' used to compute the model's likelihood function faster by reusing underlying
#' C++ class objects to store probability matrices and data. This is intended
#' for internal use only
#' 
#' @param edgelist a List two integer vectors.
#' @param Ntype An integer vector of types of size `N`.
#' @aliases aphylo_pruner
#' 
#' @details The underlying implementation of the pruning function is based on the
#' pruner C++ library that implements Felsenstein's tree pruning algorithm.
#' See ttps://github.com/USCbiostats/pruner.
#' 
#' @examples
#' set.seed(1)
#' x  <- raphylo(10) 
#' pruner <- new_aphylo_pruner(x)
#' 
#' # Computing loglike
#' LogLike(pruner, psi = c(.1, .2), mu = c(.1, .05), Pi = .5, eta = c(.9, .8))
#' 
#' @name new_aphylo_pruner
new_aphylo_pruner. <- function(edgelist, A, Ntype, nannotated) {
    .Call(`_aphylo_new_aphylo_pruner`, edgelist, A, Ntype, nannotated)
}

.LogLike_pruner <- function(tree_ptr, mu, psi, eta, Pi, verb = TRUE, check_dims = FALSE) {
    .Call(`_aphylo_LogLike_pruner`, tree_ptr, mu, psi, eta, Pi, verb, check_dims)
}

Tree_get_offspring <- function(tree_ptr) {
    .Call(`_aphylo_Tree_get_offspring`, tree_ptr)
}

Tree_get_parents <- function(tree_ptr) {
    .Call(`_aphylo_Tree_get_parents`, tree_ptr)
}

.Nnode_aphylo_pruner <- function(tree_ptr, internal_only = TRUE) {
    .Call(`_aphylo_Tree_Nnode`, tree_ptr, internal_only)
}

#' @export
#' @rdname ape-methods
Ntip.aphylo_pruner <- function(phy) {
    .Call(`_aphylo_Tree_Ntip`, phy)
}

#' @rdname ape-methods
#' @export
Nannotated.aphylo_pruner <- function(phy) {
    .Call(`_aphylo_Tree_Nannotated`, phy)
}

#' @rdname ape-methods
#' @export
Nann.aphylo_pruner <- function(phy) {
    .Call(`_aphylo_Tree_Nann`, phy)
}

root_node_pr <- function(Pi, S) {
    .Call(`_aphylo_root_node_pr`, Pi, S)
}

approx_geodesic. <- function(edges, nsteps = 5e3L, undirected = TRUE, warn = FALSE) {
    .Call(`_aphylo_approx_geodesic`, edges, nsteps, undirected, warn)
}

#' Matrix of states
#' 
#' @param P Integer scalar. Number of functions.
#' @return A matrix of size 2^P by P with all the possible
#' (0,1) combinations of functions.
#' @examples
#' states(3)
#' @export
states <- function(P) {
    .Call(`_aphylo_states`, P)
}

prob_mat <- function(pr) {
    .Call(`_aphylo_prob_mat`, pr)
}

root_node_prob <- function(Pi, S) {
    .Call(`_aphylo_root_node_prob`, Pi, S)
}

#' Reduces the peeling sequence so that only nodes that have something to contribute
#' are included in the sequence.
#' @noRd
reduce_pseq <- function(pseq, A, offspring) {
    .Call(`_aphylo_reduce_pseq`, pseq, A, offspring)
}

.posterior_prob <- function(Pr_postorder, mu, Pi, pseq, offspring) {
    .Call(`_aphylo_posterior_prob`, Pr_postorder, mu, Pi, pseq, offspring)
}

prediction_score_rand <- function(A, W, alpha) {
    .Call(`_aphylo_prediction_score_rand`, A, W, alpha)
}

.sim_fun_on_tree <- function(offspring, pseq, psi, mu, eta, Pi, P = 1L) {
    .Call(`_aphylo_sim_fun_on_tree`, offspring, pseq, psi, mu, eta, Pi, P)
}

.sim_tree <- function(n, f, branches) {
    .Call(`_aphylo_sim_tree`, n, f, branches)
}

fast_table <- function(x) {
    .Call(`_aphylo_fast_table`, x)
}

fast_table_using_labels <- function(x, ids) {
    .Call(`_aphylo_fast_table_using_labels`, x, ids)
}

.list_offspring <- function(E, n) {
    .Call(`_aphylo_list_offspring`, E, n)
}

