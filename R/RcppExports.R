# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Approximation of Geodesic distances using Matrix Powers
#' 
#' Given an adjacency matrix \eqn{A}, the geodesic can be approximated using
#' its powers, since each \eqn{(i,j)} element of \eqn{A^p} corresponds to the
#' number of \eqn{p} length steps between nodes \eqn{i} and \eqn{j}.
#' 
#' @template edges
#' @param nsteps Integer scalar. Number of maximum steps for the approximation.
#' @param warn Logical scalar. When \code{TRUE} shows a warning after no further
#' steps are needed.
#' @param undirected Logical scalar. When \code{TRUE} (default), the edgelist is treated
#' as undirected (see details).
#' @return A square matrix of size \eqn{n} with the shortest path between each
#' pair of nodes.
#' 
#' @details
#' When \code{undirected = TRUE}, the function extends \code{edges} such that
#' \code{edges = rbind(edges, edges[,2:1])}.
#' 
#' @author George G. Vega Yon
#' @references
#' This is a modified version of the function of the same name in the
#' R package \CRANpkg{netdiffuseR}.
#' @export
approx_geodesic <- function(edges, nsteps = 5e3L, undirected = TRUE, warn = FALSE) {
    .Call(`_aphylo_approx_geodesic`, edges, nsteps, undirected, warn)
}

#' Matrix of states
#' 
#' @param P Integer scalar. Number of functions.
#' @return A matrix of size 2^P by P with all the possible
#' (0,1) combinations of functions.
#' @examples
#' states(3)
#' @export
states <- function(P) {
    .Call(`_aphylo_states`, P)
}

prob_mat <- function(pr) {
    .Call(`_aphylo_prob_mat`, pr)
}

#' Reduces the peeling sequence so that only nodes that have something to contribute
#' are included in the sequence.
#' @noRd
reduce_pseq <- function(pseq, A, offspring) {
    .Call(`_aphylo_reduce_pseq`, pseq, A, offspring)
}

root_node_prob <- function(Pi, S) {
    .Call(`_aphylo_root_node_prob`, Pi, S)
}

#' State probabilities
#' 
#' Compute the state probabilities for each node in the tree using the peeling
#' algorithm. This function is the horse-power of the function \code{\link{LogLike}}
#' so it is not intended to be used directly.
#' 
#' @template parameters
#' @templateVar annotations 1
#' @templateVar mu 1
#' @templateVar psi 1
#' @templateVar eta 1
#' @templateVar S 1
#' @templateVar offspring 1
#' @param Pr A matrix.
#' 
#' @return A numeric matrix of size \eqn{n\times 2^P}{n * 2^P} with state
#' probabilities for each node.
#' @noRd
probabilities <- function(annotations, pseq, psi, mu, eta, S, offspring) {
    .Call(`_aphylo_probabilities`, annotations, pseq, psi, mu, eta, S, offspring)
}

.LogLike <- function(annotations, offspring, pseq, psi, mu, eta, Pi, verb_ans = FALSE, check_dims = TRUE) {
    .Call(`_aphylo_LogLike`, annotations, offspring, pseq, psi, mu, eta, Pi, verb_ans, check_dims)
}

predict_fun <- function(i, p, di0, annotations, offspring, pseq, psi, mu, eta, Pi) {
    .Call(`_aphylo_predict_fun`, i, p, di0, annotations, offspring, pseq, psi, mu, eta, Pi)
}

predict_funs <- function(ids, edges, annotations, offspring, pseq, psi, mu, eta, Pi) {
    .Call(`_aphylo_predict_funs`, ids, edges, annotations, offspring, pseq, psi, mu, eta, Pi)
}

.posterior_prob <- function(Pr_postorder, mu, Pi, pseq, offspring) {
    .Call(`_aphylo_posterior_prob`, Pr_postorder, mu, Pi, pseq, offspring)
}

prediction_score_rand <- function(A, W, alpha) {
    .Call(`_aphylo_prediction_score_rand`, A, W, alpha)
}

.sim_fun_on_tree <- function(offspring, pseq, psi, mu, eta, Pi, P = 1L) {
    .Call(`_aphylo_sim_fun_on_tree`, offspring, pseq, psi, mu, eta, Pi, P)
}

.sim_tree <- function(n, f, branches) {
    .Call(`_aphylo_sim_tree`, n, f, branches)
}

fast_table <- function(x) {
    .Call(`_aphylo_fast_table`, x)
}

fast_table_using_labels <- function(x, ids) {
    .Call(`_aphylo_fast_table_using_labels`, x, ids)
}

.list_offspring <- function(E, n) {
    .Call(`_aphylo_list_offspring`, E, n)
}

