% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/estimation.r, R/predict.r
\name{aphylo_estimates-class}
\alias{aphylo_estimates-class}
\alias{aphylo_estimates}
\alias{aphylo_mle}
\alias{print.aphylo_estimates}
\alias{coef.aphylo_estimates}
\alias{vcov.aphylo_estimates}
\alias{aphylo_mcmc}
\alias{predict.aphylo_estimates}
\alias{prediction_score}
\alias{print.aphylo_prediction_score}
\title{Parameter estimation of Annotated Phylogenetic Trees}
\usage{
aphylo_mle(model, params, method = "L-BFGS-B", priors = function(p) 1,
  control = list(), lower = 1e-10, upper = 1 - 1e-10,
  check.informative = getOption("aphylo.informative", FALSE),
  reduced_pseq = getOption("aphylo_reduce_pseq", FALSE))

\method{print}{aphylo_estimates}(x, ...)

\method{coef}{aphylo_estimates}(object, ...)

\method{vcov}{aphylo_estimates}(object, ...)

aphylo_mcmc(model, params, priors = uprior(), control = list(),
  check.informative = getOption("aphylo.informative", FALSE),
  reduced_pseq = getOption("aphylo_reduce_pseq", FALSE))

\method{predict}{aphylo_estimates}(object, ...)

prediction_score(x, expected = NULL, alpha = mean(x$dat$tip.annotation
  == 1L, na.rm = TRUE), W = NULL, ...)

\method{print}{aphylo_prediction_score}(x, ...)
}
\arguments{
\item{model}{A model as specified in \link{aphylo-model}.}

\item{params}{A vector of length 7 with initial parameters. In particular
\code{psi[1]}, \code{psi[2]}, \code{mu[1]}, \code{mu[2]}, \code{eta[1]}, \code{eta[2]} and \code{Pi}.}

\item{method}{Character scalar. When \code{"ABC"}, uses Artificial Bee Colony
optimization algorithm, otherwise it uses a method in \code{\link[stats:optim]{stats::optim()}}.}

\item{priors}{A function to be used as prior for the model (see \link{bprior}).}

\item{control}{A list with parameters for the optimization method (see
details).}

\item{lower, upper}{Numeric vectors defining the lower and upper bounds respectively.}

\item{check.informative}{Logical scalar. When \code{TRUE} the algorithm
stops with an error when the annotations are uninformative (either 0s or 1s).}

\item{reduced_pseq}{Logical. When \code{TRUE} it will use a reduced peeling sequence
in which it drops unannotated leafs. If the model includes \code{eta} this is set
to \code{FALSE}.}

\item{...}{Further arguments passed to the method}

\item{object, x}{An object of class \code{aphylo_estimates}.}

\item{expected}{Integer vector of length \eqn{n}. Expected values (either 0 or 1).}

\item{alpha}{Numeric scalar. Prior belief of the parameter of the bernoulli distribution
used to compute the random imputation score.}

\item{W}{A square matrix. Must have as many rows as genes in \code{expected}.}
}
\value{
A list of class \code{aphylo_estimates} with the following elements:
\item{par}{A numeric vector of length 5 with the solution.}
\item{hist}{A numeric matrix of size \code{counts*5} with the solution path (length 2 if used \code{optim}
as the intermediate steps are not available to the user).}
\item{ll}{A numeric scalar with the value of \code{fun(par, dat)}. The value of the log likelihood.}
\item{counts}{Integer scalar number of steps/batch performed.}
\item{convergence}{Integer scalar. Equal to 0 if \code{optim} converged. See \code{optim}.}
\item{message}{Character scalar. See \code{optim}.}
\item{fun}{A function (the objective function).}
\item{priors}{If specified, the function \code{priors} passed to the method.}
\item{dat}{The data \code{dat} provided to the function.}
\item{par0}{A numeric vector of length 5 with the initial parameters.}
\item{method}{Character scalar with the name of the method used.}
\item{varcovar}{A matrix of size 5*5. The estimated covariance matrix.}

In the case of \code{aphylo_mcmc}, \code{hist} is an object of class
\code{\link[coda:mcmc.list]{coda::mcmc.list()}}.

In the case of the \code{predict} method, a \code{P} column numeric matrix
with values between \eqn{[0,1]} (probabilities).
}
\description{
The optimization is done via \code{optim}.
}
\details{
\code{phylo_mcmc} is a wrapper of \link[amcmc:MCMC]{amcmc::MCMC}, so, instead of treating the
problem as a maximization problem, \code{phylo_mcmc} generates a \strong{Markov Chain}.
The default values of \code{control} are:

\tabular{ll}{
\code{nsteps} \tab Integer scalar. Number of mcmc steps. Default \code{2e3}. \cr
\code{scale} \tab Numeric scalar. Default \code{0.01}. \cr
\code{lb} \tab Numeric vector. Default \code{rep(1e-20, 5)}. \cr
\code{ub} \tab Numeric vector. Default \code{rep(1 - 1e-20, 5)}. \cr
}

In the case of \code{prediction_score}, \code{...} are passed to
\code{predict.aphylo_estimates}.
}
\examples{

# Using simulated data ------------------------------------------------------
set.seed(19)
dat <- sim_annotated_tree(100)
dat <- rdrop_annotations(dat, .4)

# Computing Estimating the parameters 
ans  <- aphylo_mle(dat ~ psi + mu + eta + Pi)
ans

# Plotting the path
plot(ans)

# Computing Estimating the parameters Using Priors for all the parameters
mypriors <- function(params) {
    dbeta(params, c(2, 2, 2, 2, 1, 10, 2), rep(10, 7))
}

ans_dbeta <- aphylo_mle(dat ~ psi + mu + eta + Pi, priors = mypriors)
ans_dbeta


# Using the MCMC ------------------------------------------------------------

\dontrun{

set.seed(1233)
# Simulating a tree
tree <- sim_tree(200)

# Simulating functions
dat <- sim_annotated_tree(
  tree = tree,
  psi  = c(.01, .03),
  mu   = c(.05, .02),
  Pi   = .5
)

# Running the MCMC
set.seed(1231)

ans_mcmc <- aphylo_mcmc(
  dat ~ mu + psi + eta + Pi,
  control = list(nsteps = 2e5, burnin=1000, thin=200, scale=2e-2)
)
}

# Example with prediction_score ---------------------------------------------
set.seed(1312)
ap  <- sim_annotated_tree(10, P = 1, Pi=.2, mu=c(.05,.02))
ans <- aphylo_mcmc(
  ap ~ mu + eta + psi + Pi,
  control = list(nsteps=2e4, thin=100),
  priors  = function(x) dbeta(x, 1, 30)
  )
                   
pr <- prediction_score(ans)
with(pr, cbind(Expected = expected, Predicted = predicted))
}
